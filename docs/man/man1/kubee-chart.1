.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "kubee-chart" "1" "" "Version Latest" "Helm with Extra\[cq]s"
.hy
.SH NAME
.PP
\f[V]kubee-chart\f[R] is the \f[V]kubee\f[R] chart manager.
.SH Features
.SS Familiar
.PP
It\[cq]s based on the following well-supported Kubernetes tools.
* Helm (https://helm.sh/), the Kubernetes Package Manager *
Kustomize (https://github.com/kubernetes-sigs/kustomize), the official
manifest customization tool * Jsonnet
Kubernetes (https://jsonnet.org/articles/kubernetes.html), the Google
configuration language
.PP
At its core, \f[V]Kubee chart\f[R] is a \f[V]Helm\f[R] wrapper.
.PP
It just executes Helm commands (https://helm.sh/docs/helm/helm/) and
therefore installs Charts (https://helm.sh/docs/topics/charts/)
.PP
All new installations: * have a history (ie
revision) (https://helm.sh/docs/helm/helm_history/) * can be
rollback (https://helm.sh/docs/helm/helm_rollback/) * can be
diffed (https://github.com/databus23/helm-diff)
.PP
There is no magic.
All commands are: * bash command, * printed to the shell (visible) * and
can be re-executed at wil
.SS New
.PP
\f[V]Kubee chart\f[R] adds support for: * \f[V]Jsonnet\f[R] - to add
Prometheus Mixin (https://monitoring.mixins.dev/)) support *
\f[V]kustomize\f[R] - to add support for application without Helm Chart
such as ArgoCd) * cluster based installation through the use of the
kubee library chart the same values are used accros multiple app/charts
* with environment variables processing * with configurable namespace
.SH Synopsis
.IP
.nf
\f[C]
kubee-chart [-c|--cluster clusterName] [--debug] command options
\f[R]
.fi
.PP
where: * \f[V]command\f[R] can be: * \f[V]play packageName\f[R] -
Upgrade or install a Kubee Chart if not present *
\f[V]upgrade packageName\f[R] - Upgrade a Kubee Chart *
\f[V]install packageName\f[R] - Install a Kubee Chart *
\f[V]template packageName\f[R] - Output the manifests for a Chart (used
for ArgoCd Integration and debugging) * \f[V]values\f[R] - Shows the
values * \f[V]-c|--cluster clusterName\f[R] - Defines the cluster *
\f[V]--output-dir string\f[R]: Writes the executed templates to files in
output-dir instead of stdout * \f[V]--out string\f[R]: Writes the
executed templates to the \f[V]out\f[R] relatif directory *
\f[V]--debug\f[R]: run in debug mode, a more verbose mode
.PP
The cluster is determined in order of precedence by:
.IP \[bu] 2
the \f[V]-c|--cluster clusterName\f[R] option
.IP \[bu] 2
the current directory
.SH What is a Kubee Chart?
.PP
A \f[V]Kubee Chart\f[R]: * is a Chart * that installs only one
application * with the name of the app installed (ie grafana, not
grafana operator) * that depends on: * the kubee Chart to share cluster
and installation wide * \f[V]values.yaml\f[R] file * and
\f[V]library\f[R] * and optionally: * cross dependency Charts: * to
bring cross values to create cross conditional expression.
Example: * conditional:
\f[V]if cert_manager.enabled then create_certificate_request\f[R] *
cross:
\f[V]if prometheus.enabled then create_grafana_data_source with promtheus.name\f[R]
* with a mandatory false condition
\f[V]kubee_internal.dont_install_dependency: false\f[R] * direct/wrapped
dependency Chart (for instance, \f[V]kubee-external-secrets\f[R] wraps
the \f[V]external-secret\f[R] Chart) * with optional \f[V]Jsonnet\f[R]
and \f[V]kustomize\f[R] processing through the kubee helm post-renderer
.IP \[bu] 2
installs only one application as \f[V]kubee\f[R] is a platform.
.RS 2
.IP \[bu] 2
For instance, installing an application such as grafana can be done via:
.RS 2
.IP \[bu] 2
a raw deployment manifest
.IP \[bu] 2
or the grafana operator
.RE
.IP \[bu] 2
Only one chart is going to supports this 2 methods.
.RE
.SH What is the Kubee Chart?
.PP
The kubee Chart is a shared chart dependency with: * a shared library *
a values.yaml
.PP
The values files has one top node for each kubee chart.
Each node contains all configurations for: * the chart * the external
services (opsgenie, new relic, grafana cloud, \&...)
- making clear what the parameters are for.
.PP
Each \f[V]values.yaml\f[R] top configuration node contains the following
common properties: * \f[V]namespace\f[R]: the namespace where to install
the chart (default to the name of the chart if not found) *
\f[V]enabled\f[R]: if the chart is used or not (default to false if not
found).
It\[cq]s used to: * conditionally applied manifest.
If there is no grafana, don\[cq]t install the dashboard * cluster
bootstrapping (ie install all charts at once)
.RS
.PP
[!Info] The \f[V]enabled\f[R] property comes from the Helm best
practices (https://helm.sh/docs/chart_best_practices/dependencies/#conditions-and-tags)
.RE
.SH What is a Jsonnet Kube-X Chart?
.PP
A \f[V]Jsonnet Kubee chart\f[R] is a chart that has only a Jsonnet
project.
.PP
It could be then: * executed only with \f[V]Jsonnet\f[R].
Example:
.IP
.nf
\f[C]
cd jsonnet
rm -rf out && mkdir -p out && jsonnet -J vendor \[rs]
  --multi out \[rs]
  \[dq]main.jsonnet\[dq]  \[rs]
  --ext-code \[dq]values={ kubee: std.parseYaml(importstr \[rs]\[dq]../../cluster/values.yaml\[rs]\[dq]) }\[dq] \[rs]
  | xargs -I{} sh -c \[aq]cat {} | gojsontoyaml > \[dq]{}.yaml\[dq] && rm {}\[aq] -- {}
\f[R]
.fi
.IP \[bu] 2
or added as Jsonnet dependency
.PP
You can then add them in GitOps Pull app such as
ArgoCd (https://argo-cd.readthedocs.io/en/stable/user-guide/jsonnet/) to
manage your infrastructure.
.SH What is the format of a Cluster Values file?
.PP
Rules: * Hard: Every root property in a cluster values file is the alias
name of the chart in \f[V]snake_case\f[R].
* Soft: Every property name should be written in \f[V]snake_case\f[R] *
Why?
\f[V]hyphen-case\f[R] is not supported by Helm Template (ie Go template)
* Why Not in \f[V]CamelCase\f[R]?
So that we get used to the fact that we don\[cq]t use \f[V]-\f[R] as a
separator
.PP
Example:
.IP
.nf
\f[C]
chart_1:
  hostname: foo.bar
  issuer_name: julia
chart_2:
  hostname: bar.foo
  dns_zones: []
\f[R]
.fi
.PP
\f[V]Kubee Chart\f[R] will transform it in a compliant Helm values.
.PP
You can see the Helm values: * to be applied with:
.IP
.nf
\f[C]
kubee-chart values --cluster clusterName chartName
\f[R]
.fi
.IP \[bu] 2
applied with:
.IP
.nf
\f[C]
helm get -n prometheus values prometheus
\f[R]
.fi
.SH Note
.SS Secret Security
.PP
With Helm, you retrieve the applied data (manifests, values) from a
storage backend.
.PP
The default storage backend for Helm is a \f[V]Kubernetes secret\f[R],
therefore the security is by default managed by Kubernetes RBAC.
.PP
Example: With this command, if you have access to the Kubernetes secret,
you should be able to see the applied values files with eventually your
secrets.
.IP
.nf
\f[C]
helm get -n namespace values chartReleaseName
\f[R]
.fi
.PP
More information can be found in the storage backend
section (https://helm.sh/docs/topics/advanced/#configmap-storage-backend)
.SS Installation Graph (DAG)
.IP \[bu] 2
Secret (used everywhere)
.IP \[bu] 2
Ingress
.SS FAQ: Why not multiple sub-chart by umbrella chart?
.PP
SubChart cannot by default installed in another namespace than the
umbrella chart.
This is a known issue with helm and
subcharts (https://github.com/helm/helm/issues/5358)
.PP
That\[cq]s why: * the unit of execution is one sub-chart by umbrella
chart * \f[V]kubee\f[R] is a common sub-chart of all umbrella chart *
this is not one \f[V]kubee\f[R] umbrella chart with multiple sub-charts

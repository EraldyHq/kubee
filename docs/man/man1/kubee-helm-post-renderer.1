.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "kubee-helm-post-renderer" "1" "" "Version Latest" "A Helm Post renderer"
.hy
.SH NAME
.PP
\f[V]kubee-helm-post-renderer\f[R] is a helm post
renderer (https://helm.sh/docs/topics/advanced/#post-rendering) that
adds support for: * \f[V]Jsonnet\f[R] * and \f[V]kustomize\f[R]
.SH SYNOPSIS
.PP
A post renderer to integrate \f[V]kustomize\f[R] and \f[V]jsonnet\f[R]
.IP
.nf
\f[C]
kubee-helm-post-renderer appDirectory valuesPath namespace output_dir
\f[R]
.fi
.PP
where:
.IP \[bu] 2
\f[V]KUBEE_CHART_DIRECTORY\f[R] is the directory of the app to install
.IP \[bu] 2
\f[V]KUBEE_VALUES_FILE\f[R] is the path to the values file
.IP \[bu] 2
\f[V]NAMESPACE\f[R] is the installation namespace
.IP \[bu] 2
\f[V]OUTPUT_DIR\f[R] is the output dir (Helm)
.PP
Note: Helm: * pass the templates output via stdin * will not print any
output if no error occurs (even with the \[en]debug flag)
.SH HOW IT WORKS
.IP \[bu] 2
if a \f[V]jsonnet\f[R] directory exists at the root of the chart
directory
.RS 2
.IP \[bu] 2
if a \f[V]jsonnetfile.json\f[R] is present, the
\f[V]jsonnet bundler\f[R] is executed to fetch dependencies
.IP \[bu] 2
the \f[V]jsonnet\f[R] files present in the \f[V]jsonnet\f[R] directory
are executed
.IP \[bu] 2
the output are added to the Helm templates
.RE
.IP \[bu] 2
if a \f[V]kustomization.yml\f[R] is present at the root of the chart
directory
.RS 2
.IP \[bu] 2
the environment variables present in \f[V]kustomization.yml\f[R] are
substituted
.IP \[bu] 2
the templates are rendered
.IP \[bu] 2
\f[V]kustomize\f[R] is applied
.IP \[bu] 2
the output is added to the Jsonnet templates if present
.RE
.SH JSONNET
.PP
The project: * file system layout is: * the project directory is the
subdirectory \f[V]jsonnet\f[R] * it contains optionally jsonnet bundler
artifacts such as: * the manifest \f[V]jsonnetfile.json\f[R] * the
\f[V]vendor\f[R] directory * the main file is called
\f[V]main.jsonnet\f[R] * can be: * opened as an independent project (by
\f[V]VsCode\f[R], \f[V]Idea\f[R]) * used as a Jsonnet bundler dependency
.IP
.nf
\f[C]
jb install https://github.com/workspace/repo/path/to/chart/jsonnet\[at]main
\f[R]
.fi
.PP
Execution: the files found at the project root directory with the
extension \f[V]jsonnet\f[R] are executed: * by default, in multimode,
each key of the Json object is a manifest path (ie Jsonnet is executed
with the \f[V]--multi\f[R] flag) * in single mode (supported but not
recommended) when the Jsonnet script name contains the term
\f[V]single\f[R] (ie the expected output should be a single json
manifest)
.PP
The Jsonnet script: * get: * the \f[V]values\f[R] file via the
\f[V]values\f[R] jsonnet external variable.
* all default values via the \f[V]values\f[R] file (no value means
error) * if in multimode, should not output manifest path that contains
directory (ie no slash in the name)
.PP
Minimal Multimode \f[V]main.jsonnet\f[R] Working Example:
.IP
.nf
\f[C]
local kxValues = std.extVar(\[aq]values\[aq]);

// The name \[ga]values\[ga] is a standard because this is similar to helm 
// (used for instance by [kube-prometheus](https://github.com/prometheus-operator/kube-prometheus/blob/8e16c980bf74e26709484677181e6f94808a45a3/jsonnet/kube-prometheus/main.libsonnet#L17))
// The values objects are flatten to allows the standard values pattern (defaultValues + values) with basic inheritance https://jsonnet.org/ref/language.html#inheritance
local values =  {
    
  prometheus_namespace: kxValues.kubee.prometheus.namespace,
    
};

// A multimode json where each key represent the name of the generated manifest and is unique
{
   // no slash, no subdirectory in the file name
   // ie not \[ga]setup/my-manifest\[ga] for instance
   \[dq]my-manifest\[dq]: {
       apiVersion: \[aq]xxx\[aq],
       kind: \[aq]xxx\[aq],
       metatdata: {
         namespace: values.prometheus_namespace
       }
    }
}
\f[R]
.fi
.PP
To validate, you can take example in our validation library.
.PP
Minimal Example:
.IP
.nf
\f[C]
local extValues = std.extVar(\[aq]values\[aq]);
local validation = import \[aq]./kubee/validation.libsonnet\[aq];
# This will throw an error if there is no property. It should as the values file should have the default.
local email = validation.getNestedPropertyOrThrow(extValues, \[aq]kubee.cluster.adminUser.email\[aq]);
# This will throw an error if there is no property and if this is the empty string.
local namespace = validation.notNullOrEmpty(extValues,\[aq]kubee.alertmanager.namespace\[aq]);
{
    \[dq]my-manifest\[dq]: {
       apiVersion: \[aq]xxx\[aq],
       kind: \[aq]xxx\[aq],
       metatdata: {
         namespace: namespace
       },
       spec: {
        email: email
       }
    }
}
\f[R]
.fi
.PP
Ide Plugins, as of 2025-01-20, choose your winner: * The Idea Databricks
Jsonnet Plugin (https://plugins.jetbrains.com/plugin/10852-jsonnet) is:
* heavy used by Databricks * can navigate the code.
\f[V]import\f[R] * works only for relatif path, * does not support
\f[V]jpath\f[R] * does not support formatting the whole document * does
not support variable renaming * no outline (structure) * supports object
heritage structure when the parsing has no errors (ie if the object
\f[V]config\f[R] defined as \f[V]config = defaults + values\f[R], you
will get to the \f[V]defaults\f[R] property structure in navigation and
intellisense) * \f[V]Find usage (F7)\f[R] is not working * The Grafana
Json Server in Vs Code (https://github.com/grafana/vscode-jsonnet) or
Intellij (https://plugins.jetbrains.com/plugin/18752-jsonnet-language-server)
* navigation works only if the document has no errors * supports
\f[V]jpath\f[R] (ie \f[V]import namespace/name\f[R] can be navigated) *
supports formatting the whole document * supports variables renaming but
not based on AST symbol (meaning that it\[cq]s just a search and replace
of a word by name, and you may ends up renaming just text, not symbol if
the name is common such as values) * no outline (structure) * does not
support object heritage structure (ie the object \f[V]config\f[R]
defined as \f[V]config = defaults +values\f[R] will not get any
intellisense on the \f[V]defaults\f[R] property) *
\f[V]Find All References\f[R] is not working
.PP
What we do: * in Databricks Intellij plugin, we develop * in Grafana
VsCode plugin, we format the whole file, we navigate \f[V]import\f[R]
statement that uses \f[V]Jpath\f[R].
.SH KUSTOMIZATION
.IP \[bu] 2
Your chart can reference Helm templates directly.
They will be rendered before passing them to \f[V]kustomize\f[R]
.IP \[bu] 2
The kustomization file can include:
.RS 2
.IP \[bu] 2
the \f[V]${KUBEE_NAMESPACE}\f[R] environment variable.
Why?
To support this
case (https://argo-cd.readthedocs.io/en/stable/operator-manual/installation/#installing-argo-cd-in-a-custom-namespace)
.RE
.PP
Example:
.IP
.nf
\f[C]
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: ${KUBEE_NAMESPACE}
patches:
  - path: templates/patches/secret-patch.yml
  - patch: |-
      - op: replace
        path: /subjects/0/namespace
        value: ${KUBEE_NAMESPACE}
    target:
      kind: ClusterRoleBinding
resources:
  - https://raw.githubusercontent.com/orga/project/xxx/manifests/install.yaml
  - templates/resources/ingress.yml
\f[R]
.fi
.RS
.PP
[!NOTE] Kustomize won\[cq]t let you have multiple resources with the
same GVK, name, and namespace because it expects each resource to be
unique.
If a resource template reports an error, setting it as a patch template,
may resolve the problem.
.RE
.SH EXAMPLE
.PP
Check the kubee-argocd chart for a kustomization example.

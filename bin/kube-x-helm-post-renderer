#!/bin/bash

# To avoid weird error on output
# Helm takes /dev/stdout and validate it
# ie unbelievable error such as:
# Error: unable to build kubernetes objects from release manifest: error validating "": error validating data: invalid object to validate
# We redirect stdout to stderr and restore it just before the end
# First save the original stdout
exec 3>&1
# Redirect all stdout to stderr
exec 1>&2

# A post renderer to integrate kustomize and jsonnet
# shellcheck source=../..//bash-lib/lib/bashlib-error.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-error.sh"
error::set_trap
set -TCEeuo pipefail
# shellcheck source=../../bash-lib/lib/bashlib-echo.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-echo.sh"
# shellcheck source=../../bash-lib/lib/bashlib-doc.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-doc.sh"
# shellcheck source=../../bash-lib/lib/bashlib-bash.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-bash.sh"
# shellcheck source=../../bash-lib/lib/bashlib-command.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-command.sh"
# shellcheck source=kube-x-lib.sh
source kube-x-lib.sh


# Check that a target directory has the same files than a source directory (in name not size)
# Create an empty file in the target directory if a source file was not found
#
# Why?
# Kustomize expects to have a file for all resources and patches
# but template Files may return an empty string and the files are not created
# if we use comments to not get an empty file
# The validation fails with
# Error: unable to build kubernetes objects from release manifest: error validating "": error validating data: invalid object to validate
# Disabling with --skip-schema-validation would not work
# Without any solution, we have written this function
create_empty_templates_with_empty_files(){

  # Source and target templates directories
  SOURCE_DIR="${1:-}"
  TARGET_DIR="${2:-}"

  # Check if both directories are provided
  if [[ "$SOURCE_DIR" == "" || "$TARGET_DIR" == "" ]]; then
    echo::err "Usage: $0 <source_directory> <target_directory>"
    return 1
  fi

  # Traverse the source directory
  find "$SOURCE_DIR" -type f -name "*.yaml" -o -name "*.yml" | while read -r source_file; do
    # Get the relative path of the file
    relative_path="${source_file#"$SOURCE_DIR"/}"
    target_file="$TARGET_DIR/$relative_path"

    # Check if the file exists in the target directory
    if [[ ! -f "$target_file" ]]; then
      # Create an empty file in the target directory
      mkdir -p "$(dirname "$target_file")"
      touch "$target_file"
      echo::info "Template File $target_file Status: Created"
    else
      echo::debug "Template File $target_file Status: Exists"
    fi
  done

}

# Start Kustomize processing
kustomize_processing(){

    echo::info "Kustomization processing (File: $KUSTOMIZATION_FILE)"

    # The root run dir is fix so that the content is deleted at every run
    # To be able to debug, the content is not deleted on error only
    KUSTOMIZE_ROOT_TEMP_DIR="$(dirname "$(mktemp -u)")/kube-x"
    rm -rf "$KUSTOMIZE_ROOT_TEMP_DIR"

    # Package Run/Temp Dir
    # The name of the directory is not random
    # It follows the usage of the output command `helm template --output-dir=$KUSTOMIZE_ROOT_TEMP_DIR`
    # The templates are then stored at $KUSTOMIZE_ROOT_TEMP_DIR/CHART_NAME/templates/...yml
    CHART_NAME=$(yq '.name' "$KUBE_X_CHART_DIRECTORY/Chart.yaml")
    KUSTOMIZE_PACKAGE_TEMP_DIR="$KUSTOMIZE_ROOT_TEMP_DIR/$CHART_NAME"
    mkdir -p "$KUSTOMIZE_PACKAGE_TEMP_DIR"

    # Output of Kustomization
    export KUBE_X_NAMESPACE
    # Variable Substitution: Check the variables
    if ! UNDEFINED_VARS=$(template::check_vars -f "$KUSTOMIZATION_FILE"); then
         # Should exit because of the strict mode
         # but it was not working
         echo::err "Values variables missing: ${UNDEFINED_VARS[*]} in file $KUSTOMIZATION_FILE"
         exit 1
    fi
    envsubst < "$KUSTOMIZATION_FILE" >| "${KUSTOMIZE_PACKAGE_TEMP_DIR}/kustomization.yml"

    # Output templates
    # helm template --output-dir /tmp
    # will output all templates one by one at: $KUSTOMIZE_ROOT_TEMP_DIR/chart-name/templates/argocd-service-monitor-metrics.yml
    command::echo_eval "helm template --output-dir $KUSTOMIZE_ROOT_TEMP_DIR -f $KUBE_X_VALUES_FILE $KUBE_X_CHART_DIRECTORY"

    # Sync
    echo::info "Create empty template files"
    create_empty_templates_with_empty_files "$KUBE_X_CHART_DIRECTORY/templates" "$KUSTOMIZE_PACKAGE_TEMP_DIR/templates"

    # The argument must be:
    # * a file system path
    # * or git repository path (git URL with path)
    # containing 'kustomization.yaml'
    # equivalent to: kustomize build .
    # https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/helmcharts/
    # https://github.com/mgoltzsche/khelm
    # Flag --reorder has been deprecated, use the new 'sortOptions' field in kustomization.yaml instead.
    if ! KUSTOMIZE_MANIFEST=$(cd "$KUSTOMIZE_PACKAGE_TEMP_DIR" && kubectl kustomize --reorder=none .); then
      echo::err "An error occurred during the kustomization"
      echo::err "The command 'kubectl kustomize .' failed with the $KUSTOMIZE_PACKAGE_TEMP_DIR working directory"
      return 1
    fi

    # we delete the directory only on success
    # most errors comes from the generation,
    if [ "$BASHLIB_ECHO_LEVEL" != "$BASHLIB_ECHO_DEBUG_LEVEL" ]; then
      rm -rf "$KUSTOMIZE_PACKAGE_TEMP_DIR"
    else
      echo::info "The command 'kubectl kustomize .' was executed with the $KUSTOMIZE_PACKAGE_TEMP_DIR working directory"
    fi

    echo "$KUSTOMIZE_MANIFEST"

}

jsonnet_processing(){

  JSONNET_DIR="jsonnet"
  if [ ! -d "$JSONNET_DIR" ]; then
    echo::info "No Jsonnet directory found"
  fi
  pushd "$JSONNET_DIR" > /dev/null
  echo::debug "Working directory for jsonnet processing is $JSONNET_DIR"
  # we can't use bash::trap on return because it's a signal processing meaning
  trap "popd > /dev/null" EXIT

  echo::info "Jsonnet processing into the Jsonnet directory $JSONNET_DIR"

  # Update the dependencies (vendor directory)
  # Mandatory when using jsonnet bundler
  JPATH="vendor"
  JSONNET_FILE="jsonnetfile.json"
  if [ ! -d "$JPATH" ] && [ -f "$JSONNET_FILE" ]; then
    JSONNET_LOCK_FILE="jsonnetfile.lock.json"
    JB_COMMAND="jb update --jsonnetpkg-home=$JPATH"
    if [ ! -f $JSONNET_LOCK_FILE ]; then
      JB_COMMAND="jb install --jsonnetpkg-home=$JPATH"
    fi
    if ! command::echo_eval "$JB_COMMAND"; then
      echo::err "Error while executing the jb command (jsonnet bundler)"
      exit 1
    fi
  fi

  # Manifest Out (the directory is called out as this is a standard (sometimes build, ...)
  JSONNET_OUTPUT_DIR="out"
  # full qualified path is needed as this command is executed at the end via trap
  REMOVE_MANIFEST_COMMAND="rm -rf $KUBE_X_CHART_DIRECTORY/$JSONNET_DIR/$JSONNET_OUTPUT_DIR"
  # In debug mode, we don't delete it to be able to check each file
  if [ "$BASHLIB_ECHO_LEVEL" != "$BASHLIB_ECHO_DEBUG_LEVEL" ]; then
    # cleaning because we may have secret in their
    bash::trap "$REMOVE_MANIFEST_COMMAND" EXIT
  else
    # To not kept old manifests, we clean
    command::echo_eval "$REMOVE_MANIFEST_COMMAND"
  fi

  # Create the output directory as it's mandatory by Jsonnet
  # Should happen after the cleaning above
  if [ ! -d "$JSONNET_OUTPUT_DIR" ]; then
    mkdir -p "$JSONNET_OUTPUT_DIR"
  fi

  # The variable to store the manifests created
  local JSONNET_MANIFESTS=""

  # Processing
  while read -r JSONNET_FILE; do

      echo::info "Processing: $JSONNET_FILE"

      JSONNET_SCRIPT_BASENAME=$(basename "$JSONNET_FILE")

      case "$JSONNET_SCRIPT_BASENAME" in
        *single*)
            echo::info "Processing in single mode the jsonnet file: $JSONNET_FILE"
              # Run
              JSONNET_MANIFEST=$(
                # --string: string as output
                command::echo_eval "jsonnet \
                  --jpath $JPATH \
                  --string \
                  --ext-code 'values=std.parseYaml(importstr \"$KUBE_X_VALUES_FILE\")' \
                  --exec 'std.manifestYamlDoc((import \"$JSONNET_FILE\"))' "
            )
            ;;
        *)

          echo::debug "The file $JSONNET_FILE does not contain mono in its name, processing in multi mode"
          echo::info "Processing in multi mode the jsonnet file: $JSONNET_FILE"

          # xargs post processing command
          # We get the list of generated file from jsonnet net
          POST_PROCESSING="xargs -I{} sh -c '"
          GOJSONTOYAML="gojsontoyaml"
          if command::exists "$GOJSONTOYAML"; then
            # transform the file to yaml
            POST_PROCESSING="$POST_PROCESSING(cat {} | $GOJSONTOYAML > {}.yaml) && "
          fi
          # Transform Json to yaml and output to stdout with yq
          # -P means pretty print and - refers to stdin
          POST_PROCESSING="$POST_PROCESSING(cat {} | yq eval -P - && echo '---')"
          # Delete the json file it yaml file were created
          if command::exists "$GOJSONTOYAML"; then
            POST_PROCESSING="$POST_PROCESSING && rm {}"
          fi
          # Echo the file name to stderr (stdout is for helm)
          POST_PROCESSING="$POST_PROCESSING && (echo {}"
          if command::exists "$GOJSONTOYAML"; then
            POST_PROCESSING="$POST_PROCESSING.yaml"
          fi
          POST_PROCESSING="$POST_PROCESSING > $(echo::get_file_descriptor))"
          # Closing
          POST_PROCESSING="$POST_PROCESSING'"

          if ! JSONNET_MANIFEST=$(
            command::echo_eval "jsonnet -J $JPATH \
            --multi $JSONNET_OUTPUT_DIR \
            --ext-code 'values=std.parseYaml(importstr \"$KUBE_X_VALUES_FILE\")' \
            $JSONNET_FILE \
            | $POST_PROCESSING"
          ); then
            echo::err "$JSONNET_MANIFEST"
            exit 1
          fi
          ;;

      esac

      # Add the jsonnet manifest
      JSONNET_MANIFESTS=$(cat <<EOF
$JSONNET_MANIFESTS
---
# Source: $JSONNET_FILE
$JSONNET_MANIFEST
EOF
  )
    # the `find` command should not be in a pipeline otherwise the JSONNET_MANIFESTS variable is
    # scoped to the pipeline and is empty
    done < <(find . -type f -maxdepth 1 -name "*.jsonnet")

    echo "$JSONNET_MANIFESTS"

}

synopsis(){
  cat <<EOF
A post renderer to integrate \`kustomize\` and \`jsonnet\`
\`\`\`bash
$(basename "$0") appDirectory valuesPath KUBE_X_NAMESPACE
\`\`\`

where:

* \`KUBE_X_CHART_DIRECTORY\` is the directory of the app to install
* \`KUBE_X_VALUES_FILE\` is the path to the values file
* \`KUBE_X_NAMESPACE\` is the installation namespace

Note: Helm:
* pass the templates output via stdin
* will not print any output if no error occurs (even with the --debug flag)
EOF
}


KUBE_X_CHART_DIRECTORY="${1:-}"

if [[ "$KUBE_X_CHART_DIRECTORY" =~ "synopsis"|"help" ]]; then
  exec 1>&3 # Restore stdout because we want the synopsis output to stdout
  exec 3>&- # Close the saved descriptor
  synopsis > /dev/stdout
  exit 0
fi

if [ ! -d "$KUBE_X_CHART_DIRECTORY" ]; then
  echo::err "Internal Error: the first argument KUBE_X_CHART_DIRECTORY ($KUBE_X_CHART_DIRECTORY) is not a valid directory"
  exit 1
fi

# Values path is already generated at this point
# that's why we pass it and not regenerate it
KUBE_X_VALUES_FILE="${2:-}"
if [ ! -f "$KUBE_X_VALUES_FILE" ]; then
  echo::err "Internal Error: the second argument values path ($KUBE_X_VALUES_FILE) is not a valid file"
  exit 1
fi

KUBE_X_NAMESPACE="${3:-}"
if [ "$KUBE_X_NAMESPACE" == "" ]; then
  echo::err "Internal Error: the third argument namespace should not be empty"
  exit 1
fi


# The whole script run in the app directory
pushd "$KUBE_X_CHART_DIRECTORY" > /dev/null
bash::trap 'popd >/dev/null' EXIT # EXIT execute also on error

# Kustomize
# Example:
# https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render
KUSTOMIZATION_FILE=$(realpath "$KUBE_X_CHART_DIRECTORY/kustomization.yml")
KUSTOMIZATION_MODE=0
if [ -f "$KUSTOMIZATION_FILE" ]; then
  KUSTOMIZATION_MODE=1
else
  echo::info "No kustomization file ($KUSTOMIZATION_FILE)"
fi

# Grab the manifests passed by Helm
HELM_MANIFEST=$(cat)

# In kustomization mode, the templates are re-created individually
# because we don't known which one is a resource and which one is a patch
# The kustomization file is the driver
if [ "$KUSTOMIZATION_MODE" -eq 1 ]; then
  HELM_MANIFEST=""
fi

##################
# JsonNet
##################
# Processing any JsonNet template if any
JSONNET_MANIFEST=$(jsonnet_processing)
if [ "$JSONNET_MANIFEST" != "" ]; then
  HELM_MANIFEST=$(cat <<EOF
$HELM_MANIFEST
---
$JSONNET_MANIFEST
EOF
)
fi

# Kustomize
# Example:
# https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render
if [ "$KUSTOMIZATION_MODE" -eq 1 ]; then
  KUSTOMIZE_MANIFEST=$(kustomize_processing)
  # Add the kustomize manifest
  HELM_MANIFEST=$(cat <<EOF
$HELM_MANIFEST
---
$KUSTOMIZE_MANIFEST
EOF
  )
fi

# Output

# Later, restore stdout from saved descriptor
exec 1>&3
# Close the saved descriptor
exec 3>&-

echo "$HELM_MANIFEST"

#!/bin/bash
# @name kube-app-env
# @description
#   Print the export environment statement for the app
#
#   Used in a direnv setup


# shellcheck source=./bashlib-error.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-error.sh"
error::set_strict_mode
error::set_trap
# shellcheck source=./bashlib-echo.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-echo.sh"
# shellcheck source=./bashlib-doc.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-doc.sh"
# shellcheck source=./bashlib-path.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-path.sh"
# shellcheck source=./bashlib-bash.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-bash.sh"
# shellcheck source=./bashlib-command.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-command.sh"

# @description test the connection to the cluster
test_connection(){

  if OUTPUT=$($KUBE_X_KUBECTL cluster-info); then
    echo::debug "Connection succeeded"
    return 0;
  fi
  echo::err "No connection could be made with the cluster"

  case "$KUBE_X_KUBECTL" in
    "kubectl")
      if [ -z "$KUBECONFIG" ]; then
            echo::err "Note: No KUBECONFIG env found"
      else
          if [ ! -f "$KUBECONFIG" ]; then
            echo::err "The KUBECONFIG env file ($KUBECONFIG) does not exist"
          else
            echo::info "The file ($KUBECONFIG) may have bad cluster info"
            echo::err "Note: The config is:"
            kubectl config view
          fi
      fi
      ;;
    "kubectx")
        echo::err "Note: The kubectx config is:"
        kubectx config view --raw
      ;;
    *)
        echo::err "The KUBE_X_KUBECTL value $KUBE_X_KUBECTL is unknown";
        ;;
  esac

  echo::err "We got the following output from the connection"
  echo::err "$OUTPUT"
  return 1

}

synopsis(){

cat <<EOF
Print the kubernetes and kube-x environment variables in a export format
\`\`\`bash
$(basename "$0") [<app name>]
\`\`\`

where \`app name\` is optional if the current directory is below the \`KUBE_X_APP_HOME\`.

EOF

}


######################
# Main
######################

KUBE_X_APP_NAME=${1:-}


# Synopsis
if [[ "$KUBE_X_APP_NAME" = "synopsis" ]]; then
  synopsis
  exit 0
fi

# Help ?
if [[ "$KUBE_X_APP_NAME" =~ -h|--help|help ]]; then
  doc::help synopsis
  exit 0
fi

###########################
# Kube App home
###########################
if [ "${KUBE_X_APP_HOME:-}" == "" ]; then
  echo::err "The KUBE_X_APP_HOME environment variable is mandatory and was not found"
  echo::err "Add it in your bashrc or OS environment variables"
  exit 1
fi


###########################
# App Name
###########################
if [ "$KUBE_X_APP_NAME" == "" ]; then
  IFS=":"; for KUBE_X_HOME in $KUBE_X_APP_HOME; do
      if [ ! -d "$KUBE_X_HOME" ]; then
        echo::warn "The HOME path ($KUBE_X_HOME) set in KUBE_X_APP_HOME does not exist or is not a directory"
        continue
      fi
      KUBE_X_APP_NAME=$(path::relative_to "$PWD" "$KUBE_X_HOME") || continue
      break
  done
  if [ "$KUBE_X_APP_NAME" == "" ]; then
      echo::err "App name could not be determined."
      echo::err "* No app name was passed as parameter"
      echo::err "* The working directory ($PWD) is not under a KUBE_X_APP_HOME path ($KUBE_X_APP_HOME)"
      exit 1
  fi
fi
echo "export KUBE_X_APP_NAME=$KUBE_X_APP_NAME"


###########################
# envrc: Load the user env
###########################
KUBE_X_APP_DIR=""
IFS=":"; for KUBE_X_HOME in $KUBE_X_APP_HOME; do
  APP_DIR=$KUBE_X_HOME/$KUBE_X_APP_NAME
  if [ -d "$APP_DIR" ]; then
    KUBE_X_APP_DIR="$APP_DIR"
    break
  fi
done
if [ "$KUBE_X_APP_DIR" == "" ]; then
  echo::err "No sub-directory with the name $KUBE_X_APP_NAME was found under the KUBE_X_APP_HOME paths ($KUBE_X_APP_HOME)"
  exit 1
fi
echo "export KUBE_X_APP_DIR=$KUBE_X_APP_DIR"

# Go to the app dir and pop at err and exit
pushd "$KUBE_X_APP_DIR" >/dev/null || return 1
bash::trap 'popd >/dev/null' EXIT # EXIT execute also on error

# Load the env
if command::exists "direnv"; then
    # Direnv should be explicitly called in non-interactive mode
    # https://github.com/direnv/direnv/issues/262
    if ! bash::is_interactive; then
      eval "$(direnv export bash)"
    fi
else
  echo::warn "Direnv not found on path"
  ENVRC_FILE="$KUBE_X_APP_DIR/.envrc"
  if [ -f "$ENVRC_FILE" ]; then
    # shellcheck disable=SC1090
    source "$ENVRC_FILE"
  else
    echo::warn "File $ENVRC_FILE not found"
  fi
fi

###########################
# Derived Env
###########################
KUBE_X_NAMESPACE=${KUBE_X_NAMESPACE:-"$KUBE_X_APP_NAME"}
echo "export KUBE_X_NAMESPACE=$KUBE_X_NAMESPACE"


###########################
# Connection test
###########################
# We test the connection because otherwise the user
# may get a message that a resource could not be found
# where the culprit should have been the connection
KUBE_X_KUBECTL=${KUBE_X_KUBECTL:-"kubectl"}
echo "export KUBE_X_KUBECTL=$KUBE_X_KUBECTL"

# Test Connection
KUBE_X_NAMESPACE=$KUBE_X_NAMESPACE test_connection



#!/usr/bin/env bash


# shellcheck source=../../bash-lib/lib/bashlib-template.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-template.sh"



inventory_file(){

   # Inventory
   local KUBEE_INVENTORY_FILE="${KUBEE_INFRA_INVENTORY_FILE:-"$KUBEE_CLUSTER_DIR/ansible-inventory.yml"}"

   # If there is non, we generate one with the kubee infra chart
   if [ ! -f "$KUBEE_INVENTORY_FILE" ]; then

     echo::debug "Cluster ansible inventory file $KUBEE_INVENTORY_FILE does not exist, using the kubee inventory chart output"
     KUBEE_INVENTORY_FILE="/dev/shm/kubee-infra-inventory.yml"
     # Log level of the sub command
     local BASHLIB_INFRA_TEMPLATE_LEVEL=$BASHLIB_ECHO_WARNING_LEVEL
     # If command or debug message, log also them in the template
     if [ "$BASHLIB_ECHO_LEVEL" -ge "$BASHLIB_ECHO_COMMAND_LEVEL" ]; then
       BASHLIB_INFRA_TEMPLATE_LEVEL=$BASHLIB_ECHO_LEVEL
     fi
     if ! echo::eval "BASHLIB_ECHO_LEVEL=$BASHLIB_INFRA_TEMPLATE_LEVEL; source kubee-helmet template -s templates/ansible-inventory.yml infra 2>$COMMAND_STDOUT_FD >| $KUBEE_INVENTORY_FILE"; then
       echo::err "An error occurred while templating the infra chart"
       return 1
     fi
     echo "$KUBEE_INVENTORY_FILE"
     return

   fi

   # Minimal templating with envsubst
   # Check the variables
   if ! UNDEFINED_VARS=$(template::check_vars -f "$KUBEE_INVENTORY_FILE"); then
     # Should exit because of the strict mode
     # but it was not working
     echo::err "Inventory variables missing: ${UNDEFINED_VARS[*]}"
     return 1
   fi
   local SHM_INVENTORY_FILE="/dev/shm/kubee-ansible-inventory.yml"

   echo::eval "envsubst < $KUBEE_INVENTORY_FILE >| $SHM_INVENTORY_FILE"
   echo "$SHM_INVENTORY_FILE"


}



play(){

  ansible-playbook -i "$SHM_INVENTORY_FILE" ans_e.ans_e_base.kubee_site.yml

}

upgrade(){

  ansible-playbook -i "$SHM_INVENTORY_FILE" k3s.orchestration.upgrade.yml

}

ping(){
  # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ping_module.html

  ansible -i "$SHM_INVENTORY_FILE" all -m ping

}

# @internal
synopsis(){

local CLI_NAME;
CLI_NAME=$(basename "$(script::get_actual_script)" | tr "-" " ")
cat << EOT

$CLI_NAME - Cluster Hosts Management

Usage:
\`\`\`bash
$CLI_NAME [options] command args
\`\`\`

Commands:

* play             Deploy Kubernetes on the cluster hosts (Repeatable install and configuration)
* upgrade          Upgrade Kubernetes on the cluster hosts
* inventory        Print the cluster hosts inventory file
* ping             Verify the connection to the clusters hosts
* shell            Start a pod and get a shell in the cluster

Options:

* -h --help        Show this help message


EOT
}



# Assign the first argument to a string
CLUSTER_COMMAND="${1:-}"
if [ "$CLUSTER_COMMAND" = "" ]; then
    synopsis
    echo::err "A command is mandatory"
    exit 1
fi
shift  # Remove the first argument from the argument list

# Help Asked should not fail for the doc
# We test if before the error warning
if [[ $CLUSTER_COMMAND =~ help|-h|--help ]]; then
  doc::help synopsis
  exit
fi

if [[ $CLUSTER_COMMAND == "synopsis" ]]; then
  synopsis
  exit
fi

# Cluster Directory
if [ "$KUBEE_CLUSTER_NAME" == "" ]; then
  echo::err "The cluster is mandatory"
  exit 1
fi

KUBEE_CLUSTER_DIR=$(kubee::get_cluster_directory "$KUBEE_CLUSTER_NAME")
# Envrc
# Used in all function
KUBEE_ENV_FILE="${KUBEE_CLUSTER_ENV_FILE:-"$KUBEE_CLUSTER_DIR/.envrc"}"
if [ -f "$KUBEE_ENV_FILE" ]; then
   echo::debug "Sourcing cluster env file $KUBEE_ENV_FILE"
   # shellcheck disable=SC1090
   if ! source "$KUBEE_ENV_FILE"; then
     echo::err "Error while importing the envrc file $KUBEE_ENV_FILE"
     exit 1
   fi
fi

# Inventory
if ! SHM_INVENTORY_FILE=$(inventory_file); then
 echo::err "Inventory file has errors"
 return 1
fi

# Private Key file
export ANSIBLE_PRIVATE_KEY_FILE="${ANSIBLE_PRIVATE_KEY_FILE:-}"
if [ "$ANSIBLE_PRIVATE_KEY_FILE" == "" ]; then
  if [ "${KUBEE_INFRA_CONNECTION_PRIVATE_KEY_FILE:-""}" != "" ]; then
    export ANSIBLE_PRIVATE_KEY_FILE="${KUBEE_CLUSTER_SERVER_CONNECTION_PRIVATE_KEY_FILE}"
  else
    if [ "${KUBEE_INFRA_CONNECTION_PRIVATE_KEY:-""}" != "" ]; then

      export ANSIBLE_PRIVATE_KEY_FILE="/dev/shm/ssh-key"
      echo "$KUBEE_INFRA_CONNECTION_PRIVATE_KEY" >| "$ANSIBLE_PRIVATE_KEY_FILE"

    else

      echo::warn "No server connection private key found in env"
      echo::warn ""
      echo::warn "Ssh will try to connect with"
      echo::warn " * the ssh agent keys if running"
      echo::warn " * the default ssh keys in ~/.ssh"
      echo::warn "If there is none, the connection will failed"
      echo::warn ""
      echo::warn "The following environment variables were empty"
      echo::warn "  * ANSIBLE_PRIVATE_KEY_FILE"
      echo::warn "  * KUBEE_INFRA_CONNECTION_PRIVATE_KEY_FILE"
      echo::warn "  * KUBEE_INFRA_CONNECTION_PRIVATE_KEY"

    fi
  fi
fi
if [ "${ANSIBLE_PRIVATE_KEY_FILE:-""}" != "" ]; then
  # to avoid Permissions 0644 for '/tmp/ssh-key' are too open
  # as we mount with the current user, docker inherit the permissions
  chmod 600 "$ANSIBLE_PRIVATE_KEY_FILE"
fi


case $CLUSTER_COMMAND in
"play")
    play "$@" || error::exit $?
    ;;
"inventory"|"inv")
    yq "$SHM_INVENTORY_FILE"
    ;;
"upgrade")
    upgrade "$@" || error::exit $?
    ;;
"ping")
    ping "$@" || error::exit $?
    ;;
"shell")
    source kubee-app-shell "busybox" "$@" || error::exit $?
    ;;
*)
  doc::help synopsis
  echo::err "Command $CLUSTER_COMMAND is unknown"
  exit 1
esac

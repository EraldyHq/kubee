#!/bin/bash
# @name kube-app-env
# @description
#   Print the export environment statement for the app
#
#   Used in a direnv setup





synopsis(){

cat <<EOF
Print the kubernetes and kubee environment variables in a export format
\`\`\`bash
$(basename "$0") [<chart name>]
\`\`\`

where \`chart name\` is optional if the current directory is below a \`KUBEE_CHARTS_PATH\`.

EOF

}


######################
# Main
######################

KUBEE_APP_NAME=${1:-}


# Synopsis
if [[ "$KUBEE_APP_NAME" = "synopsis" ]]; then
  synopsis
  exit 0
fi

# Help ?
if [[ "$KUBEE_APP_NAME" =~ -h|--help|help ]]; then
  doc::help synopsis
  exit 0
fi

set_kubeconfig_env(){

  if [ "${KUBECONFIG:-}" != "" ]; then
    echo::debug "KUBECONFIG env already set to: $KUBECONFIG"
    return
  fi

  export KUBECONFIG="$HOME/.kube/config"
  if  [ -f "$KUBECONFIG" ]; then
    echo::debug "KUBECONFIG set to the existing default config file: $KUBECONFIG"
    return
  fi

  if ! command::exists "pass"; then
    echo::err "KUBECONFIG was not found"
    echo::err "The pass command was not found, we cannot generate a KUBECONFIG file"
    return 1
  fi
  # Config does not work with process substitution (ie /dev/
  # It seems that it starts another process deleting/closing the file descriptor

  # Trap work exit  also on source
  # https://stackoverflow.com/questions/69614179/bash-trap-not-working-when-script-is-sourced
  # As what we want is to delete it after the main script
  # We just output the trap statement
  # Note: On kubectl, we could also just pass the data but we should
  # do that for all kubernetes clients (promtool, ...) and this is pretty hard
  KUBECONFIG="/dev/shm/kubee-config" # we create a shared memory file because we test the presence of the file
  chmod 0600 /dev/shm/kubee-config # same permission as ssh key
  if ! kubee::connection_generate_config_from_pass >| /dev/shm/kubee-config; then
    echo::err "Error while generating the config file with pass"
    return 1
  fi

}

###########################
# App Name
###########################
#if [ "$KUBEE_APP_NAME" == "" ]; then
#  # Check if we are under a $KUBEE_CHARTS_PATH
#  IFS=":"; for KUBEE_HOME in $KUBEE_CHARTS_PATH; do
#      if [ ! -d "$KUBEE_HOME" ]; then
#        echo::warn "The HOME path ($KUBEE_HOME) set in KUBEE_APP_HOME does not exist or is not a directory"
#        continue
#      fi
#      KUBEE_APP_NAME=$(path::relative_to "$PWD" "$KUBEE_HOME") || continue
#      break
#  done
##  if [ "$KUBEE_APP_NAME" == "" ]; then
##      echo::err "App name could not be determined."
##      echo::err "* No app name was passed as parameter"
##      echo::err "* The working directory ($PWD) is not under a KUBEE_APP_HOME path ($KUBEE_APP_HOME)"
##  fi
#fi
#echo ""
#echo "# The name of the app"
#echo "KUBEE_APP_NAME=$KUBEE_APP_NAME"


###########################
# App dir and envrc: Load the user env
###########################
#KUBEE_APP_DIR=""
#if [ "$KUBEE_APP_NAME" != "" ]; then
#
#  # Set the internal field separator to a colon, but only for the command
#  IFS=':' read -r -a KUBEE_HOMES <<< "$KUBEE_APP_HOME"
#  for KUBEE_HOME in "${KUBEE_HOMES[@]}"; do
#    APP_DIR=$KUBEE_HOME/$KUBEE_APP_NAME
#    if [ -d "$APP_DIR" ]; then
#      KUBEE_APP_DIR="$APP_DIR"
#      break
#    fi
#  done
#
#  if [ "$KUBEE_APP_DIR" == "" ]; then
#    # App Name may be a component (example: alert manager)
#    echo::warn "No sub-directory with the name $KUBEE_APP_NAME was found under the KUBEE_APP_HOME paths (${KUBEE_HOMES[@]})"
#  else
#    # App specific env
#    # Should be first
#    # Go to the app dir and pop at err and exit
#    pushd "$KUBEE_APP_DIR" >/dev/null || return 1
#    bash::trap 'popd >/dev/null' EXIT # EXIT execute also on error
#
#    # Load the env
#    if command::exists "direnv"; then
#        # Direnv should be explicitly called in non-interactive mode
#        # https://github.com/direnv/direnv/issues/262
#        if ! bash::is_interactive; then
#          eval "$(direnv export bash)"
#        fi
#    else
#      echo::warn "Direnv not found on path"
#      ENVRC_FILE="$KUBEE_APP_DIR/.envrc"
#      if [ -f "$ENVRC_FILE" ]; then
#        # shellcheck disable=SC1090
#        source "$ENVRC_FILE"
#      else
#        echo::warn "File $ENVRC_FILE not found"
#      fi
#    fi
#
#  fi
#
#fi
#echo ""
#echo "# The directory of the app"
#echo "KUBEE_APP_DIR=$KUBEE_APP_DIR"

# The cluster
KUBEE_CLUSTER_NAME=${KUBEE_CLUSTER_NAME:-}

# Cluster Directory
if [ "$KUBEE_CLUSTER_NAME" != "" ]; then

  KUBEE_CLUSTER_DIR=$(kubee::get_cluster_directory "$KUBEE_CLUSTER_NAME")
  # Envrc
  # Used in all function
  KUBEE_ENV_FILE="${KUBEE_CLUSTER_ENV_FILE:-"$KUBEE_CLUSTER_DIR/.envrc"}"
  if [ -f "$KUBEE_ENV_FILE" ]; then
     echo::debug "Sourcing cluster env file $KUBEE_ENV_FILE"
     # shellcheck disable=SC1090
     if ! source "$KUBEE_ENV_FILE"; then
       echo::err "Error while importing the envrc file $KUBEE_ENV_FILE"
       exit 1
     fi
  fi
fi


#############################
# All env with default value
# Should be after app envrc call
#############################


## Connection namespace
# The namespace for the connection (in the kubectx kubeconfig context)
KUBEE_CHART_NAMESPACE=${KUBEE_CHART_NAMESPACE:-"default"}


# The username for the connection (in the kubeconfig context)"
KUBEE_USER_NAME=${KUBEE_USER_NAME:-"default"}

# The connection namespace
KUBEE_CONNECTION_NAMESPACE=${KUBEE_CONNECTION_NAMESPACE:-"default"}

# The name of the context (in kubectx kubeconfig)"
KUBEE_CONTEXT_NAME=${KUBEE_CONTEXT_NAME:-"$KUBEE_USER_NAME@$KUBEE_CLUSTER_NAME/$KUBEE_CONNECTION_NAMESPACE"}

# The directory for the kubeconfig data in the pass store manager"
KUBEE_PASS_HOME=${KUBEE_PASS_HOME:-"kubee"}

# The busybox image to use for a shell in a busybox or ephemeral container"
KUBEE_BUSYBOX_IMAGE=${KUBEE_BUSYBOX_IMAGE:-ghcr.io/gerardnico/busybox:latest}



set_kubeconfig_env || error::exit $?

if [ ! -f "$KUBECONFIG" ]; then
 echo::warn "The \$KUBECONFIG variable points to the file $KUBECONFIG that does not exist"
fi

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "api_token": {
      "default": "",
      "description": "The auth credential (used only for an external instance). See [doc](https://grafana.com/docs/grafana-cloud/developer-resources/infrastructure-as-code/grafana-operator/operator-dashboards-folders-datasources/#grafana-operator-setup)",
      "required": [],
      "title": "api_token"
    },
    "cert_manager": {
      "description": "The Cert Manager Kubee Chart",
      "properties": {
        "cert-manager": {
          "description": " defined by either the name or alias of your dependency in Chart.yaml @ignored",
          "properties": {
            "clusterResourceNamespace": {
              "default": "",
              "description": "cluster-resource-namespace=my-namespace https://cert-manager.io/docs/configuration/#cluster-resource-namespace The Cluster Resource Namespace is defaulted as being the `cert-manager` namespace, A ClusterIssuer CA will create the certificate in this namespace https://cert-manager.io/docs/configuration/ca/#deployment",
              "required": [],
              "title": "clusterResourceNamespace"
            },
            "crds": {
              "properties": {
                "enabled": {
                  "default": false,
                  "required": [],
                  "title": "enabled",
                  "type": "boolean"
                }
              },
              "required": [],
              "title": "crds",
              "type": "object"
            },
            "namespace": {
              "default": "{{ .Values.namespace }}",
              "description": "Installation namespace",
              "required": [],
              "title": "namespace",
              "type": "string"
            },
            "prometheus": {
              "description": " https://github.com/cert-manager/cert-manager/blob/master/deploy/charts/cert-manager/README.template.md#prometheus",
              "properties": {
                "enabled": {
                  "default": false,
                  "description": "We don't create it ourselves because it's pretty hard.",
                  "required": [],
                  "title": "enabled",
                  "type": "boolean"
                },
                "servicemonitor": {
                  "properties": {
                    "enabled": {
                      "default": false,
                      "required": [],
                      "title": "enabled",
                      "type": "boolean"
                    }
                  },
                  "required": [],
                  "title": "servicemonitor",
                  "type": "object"
                }
              },
              "required": [],
              "title": "prometheus"
            },
            "webhook": {
              "properties": {
                "timeoutSeconds": {
                  "default": 4,
                  "required": [],
                  "title": "timeoutSeconds",
                  "type": "integer"
                }
              },
              "required": [],
              "title": "webhook",
              "type": "object"
            }
          },
          "required": [],
          "title": "cert-manager"
        },
        "enabled": {
          "default": "false",
          "description": "If true, cert-manager is or will be installed on the cluster When disabled, the default ingress certificate specified on Traefik is used Not a string, a boolean so no quote",
          "required": [],
          "title": "enabled"
        },
        "global": {
          "description": "Global values are values that can be accessed from any chart or subchart by exactly the same name.",
          "required": [],
          "title": "global",
          "type": "object"
        },
        "issuers": {
          "description": "The ca issuers",
          "properties": {
            "kubee": {
              "description": "The kubee issuer is used to create certificates for the internal service and pods (ie the local private domain cluster.local)",
              "properties": {
                "bundle_name": {
                  "const": "kubee-ca-bundle",
                  "default": "kubee-ca-bundle",
                  "description": " const: 'kubee-ca-bundle' @schema The kubee cert bundle with the root CA and the kubee ca cert It's distributed to clients to create secure TLS connection",
                  "required": [],
                  "title": "bundle_name"
                },
                "name": {
                  "const": "kubee-ca",
                  "default": "kubee-ca",
                  "description": " const: 'kubee-ca' @schema The kubee issuer name.",
                  "required": [],
                  "title": "name"
                }
              },
              "required": [],
              "title": "kubee"
            },
            "public": {
              "description": "The public issuer name. The public issuer is used to create certificate for public access (ie public network / public domain name) Its name should be changed to `letsencrypt-prod` when the `letsencrypt-staging` is working and validated",
              "properties": {
                "name": {
                  "default": "letsencrypt-staging",
                  "description": " enum: [ 'letsencrypt-staging', 'letsencrypt-prod' ] required: true @schema The public issuer name.",
                  "enum": [
                    "letsencrypt-staging",
                    "letsencrypt-prod"
                  ],
                  "required": [],
                  "title": "name"
                }
              },
              "required": [],
              "title": "public"
            }
          },
          "required": [],
          "title": "issuers",
          "type": "object"
        },
        "kubee_internal": {
          "description": " Don't touch, used to block template output of cross dependency",
          "properties": {
            "install_cross_dependency": {
              "default": false,
              "required": [],
              "title": "install_cross_dependency",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "kubee_internal"
        },
        "namespace": {
          "default": "cert-manager",
          "description": "The installation namespace",
          "required": [],
          "title": "namespace"
        },
        "trust-manager": {
          "description": " @ignored",
          "properties": {
            "app": {
              "properties": {
                "metrics": {
                  "properties": {
                    "service": {
                      "properties": {
                        "servicemonitor": {
                          "properties": {
                            "enabled": {
                              "default": false,
                              "description": "We do it ourselves so that there is some logic",
                              "required": [],
                              "title": "enabled",
                              "type": "boolean"
                            }
                          },
                          "required": [],
                          "title": "servicemonitor",
                          "type": "object"
                        }
                      },
                      "required": [],
                      "title": "service",
                      "type": "object"
                    }
                  },
                  "required": [],
                  "title": "metrics",
                  "type": "object"
                }
              },
              "required": [],
              "title": "app",
              "type": "object"
            },
            "crds": {
              "properties": {
                "enabled": {
                  "default": "false",
                  "description": " no matches for kind \"Bundle\" in version \"trust.cert-manager.io/v1alpha1\"",
                  "required": [],
                  "title": "enabled"
                }
              },
              "required": [],
              "title": "crds",
              "type": "object"
            },
            "secretTargets": {
              "description": "Traefik require the TLS data to be secret",
              "properties": {
                "authorizedSecrets": {
                  "description": " not be good executing from another context when creating our values file",
                  "items": {
                    "anyOf": [
                      {
                        "required": [],
                        "type": "string"
                      }
                    ],
                    "required": []
                  },
                  "required": [],
                  "title": "authorizedSecrets"
                },
                "enabled": {
                  "default": true,
                  "required": [],
                  "title": "enabled",
                  "type": "boolean"
                }
              },
              "required": [],
              "title": "secretTargets",
              "type": "object"
            }
          },
          "required": [],
          "title": "trust-manager"
        }
      },
      "required": [],
      "title": "kubee-cert-manager",
      "type": "object"
    },
    "cluster": {
      "description": "The kubee cluster chart",
      "properties": {
        "auth": {
          "description": "Cluster Auth",
          "properties": {
            "admin_user": {
              "description": "The admin user  * created as admin user in Kubernetes and other app  * added in basicAuth",
              "properties": {
                "cluster_role": {
                  "default": "cluster-admin",
                  "description": " required: true enum: [ 'cluster-admin', 'admin' ] @schema Kubernetes clusterRole * `cluster-admin` has full access * `admin` does not have access to node and cluster scope related object such as ClusterRoleBinding",
                  "enum": [
                    "cluster-admin",
                    "admin"
                  ],
                  "required": [],
                  "title": "cluster_role"
                },
                "email": {
                  "default": "",
                  "description": " format: email minLength: 1 @schema The admin email It's used by default in apps. For instance: * letsencrypt registration email * alert notifications: prometheus, argocd",
                  "format": "email",
                  "minLength": 1,
                  "required": [],
                  "title": "email"
                },
                "password": {
                  "default": "",
                  "description": " required: true minLength: 1 @schema The admin password",
                  "minLength": 1,
                  "required": [],
                  "title": "password"
                },
                "username": {
                  "default": "admin",
                  "description": " required: true minLength: 3 @schema The username",
                  "minLength": 3,
                  "required": [],
                  "title": "username"
                }
              },
              "required": [],
              "title": "admin_user"
            },
            "trusted_proxies": {
              "description": "Trusted Proxies If trusted, reverse proxies handler will proxy and augment the sensitive X-Forwarded-* request headers.  You should set the CIDR value of: * internal proxy such as traefik * and external proxy such as cloudflare It's used by Traefik and all auth application that needs the real ip and trust the X-forward headers",
              "items": {
                "required": []
              },
              "required": [],
              "title": "trusted_proxies"
            }
          },
          "required": [],
          "title": "auth",
          "type": "object"
        },
        "chart": {
          "default": "k3s-ansible",
          "description": "The cluster chart. The cluster chart is responsible for the installation/management of Kubernetes on the nodes",
          "required": [],
          "title": "chart"
        },
        "distribution": {
          "default": "k3s",
          "description": "The kubernetes distribution k3s is the distribution that has a cluster chart implemented.",
          "required": [],
          "title": "distribution"
        },
        "dns": {
          "description": " it's used by cert-manager for the DNS01 proof and by external dns",
          "properties": {
            "cloudflare": {
              "description": "Cloudflare Enabled if the domain list is not empty",
              "properties": {
                "api_token": {
                  "description": " `ApiToken` is now the preferred method (ApiKey is deprecated)",
                  "properties": {
                    "key": {
                      "default": "cloudflare-api-token",
                      "description": " required: true minLength: 1 @schema The key property (in the secret of k8s or any other provider)",
                      "minLength": 1,
                      "required": [],
                      "title": "key"
                    },
                    "kind": {
                      "default": "Secret",
                      "description": " required: true enum: [ 'Secret', 'ExternalSecret' ] @schema The type of secret A secret or external secret The chart is responsible for supporting them",
                      "enum": [
                        "Secret",
                        "ExternalSecret"
                      ],
                      "required": [],
                      "title": "kind"
                    },
                    "property": {
                      "default": "",
                      "description": " Used with the External Secret type",
                      "required": [],
                      "title": "property"
                    },
                    "value": {
                      "default": "",
                      "description": " (Used with the k8s secret type to create a Kubernetes secret)",
                      "required": [],
                      "title": "value"
                    }
                  },
                  "required": [],
                  "title": "api_token"
                },
                "dns_zones": {
                  "description": " format: hostname required: true minLength: 0 @schema The dns Zones that are managed by cloudflare, Cloudflare is enabled if the list is not empty",
                  "format": "hostname",
                  "items": {
                    "required": []
                  },
                  "minLength": 0,
                  "required": [],
                  "title": "dns_zones"
                }
              },
              "required": [],
              "title": "cloudflare"
            }
          },
          "required": [],
          "title": "dns"
        },
        "email": {
          "description": "Default smtp server parameters",
          "properties": {
            "smtp": {
              "description": "Smtp Configuration",
              "properties": {
                "from": {
                  "default": "",
                  "description": " format: email required: false @schema the default from",
                  "format": "email",
                  "required": [],
                  "title": "from"
                },
                "hello": {
                  "default": "",
                  "description": "hello (used to present itself, normally the email apex domain name)",
                  "required": [],
                  "title": "hello",
                  "type": "string"
                },
                "host": {
                  "default": "",
                  "description": " title: Smtp host description: The smtp hostname required: true format: hostname @schema The smtp host if the host is not empty, smtp configuration are added for example for argocd email notifications",
                  "format": "hostname",
                  "required": [],
                  "title": "Smtp host"
                },
                "password": {
                  "default": "",
                  "description": "the auth connection password",
                  "required": [],
                  "title": "password",
                  "type": "string"
                },
                "port": {
                  "default": 465,
                  "description": " title: Smtp Port description: The Smtp port type: integer required: false @schema the smtp port",
                  "required": [],
                  "title": "Smtp Port",
                  "type": "integer"
                },
                "username": {
                  "default": "",
                  "description": "the auth connection username",
                  "required": [],
                  "title": "username",
                  "type": "string"
                }
              },
              "required": [],
              "title": "smtp"
            }
          },
          "required": [],
          "title": "email",
          "type": "object"
        },
        "global": {
          "description": "Global values are values that can be accessed from any chart or subchart by exactly the same name.",
          "required": [],
          "title": "global",
          "type": "object"
        },
        "name": {
          "default": "kubee",
          "description": "The cluster name used: * to identify the cluster (for instance, on prometheus remote-write metrics, the name is added as label) * as default first instance name for operator (for instance, prometheus operator allows to install multiple prometheus that needs to be unique. Kube-prometheus asks for a unique name)",
          "required": [],
          "title": "name"
        }
      },
      "required": [],
      "title": "kubee-cluster",
      "type": "object"
    },
    "data_sources": {
      "description": " The data sources created",
      "properties": {
        "prometheus": {
          "properties": {
            "name": {
              "const": "prometheus",
              "default": "prometheus",
              "description": " const: prometheus @schema",
              "required": [],
              "title": "name"
            }
          },
          "required": [],
          "title": "prometheus",
          "type": "object"
        }
      },
      "required": [
        "prometheus"
      ],
      "title": "data_sources"
    },
    "enabled": {
      "default": false,
      "description": "Boolean to indicate that this chart is or will be installed in the cluster",
      "required": [],
      "title": "Enabled",
      "type": "boolean"
    },
    "global": {
      "description": "Global values are values that can be accessed from any chart or subchart by exactly the same name.",
      "required": [],
      "title": "global",
      "type": "object"
    },
    "grafana-operator": {
      "description": "Helm chart for the Grafana Operator",
      "properties": {
        "additionalLabels": {
          "description": "additional labels to add to all resources",
          "required": [],
          "title": "additionalLabels"
        },
        "affinity": {
          "description": "pod affinity",
          "required": [],
          "title": "affinity"
        },
        "env": {
          "description": "Additional environment variables",
          "items": {
            "required": []
          },
          "required": [],
          "title": "env"
        },
        "extraObjects": {
          "description": "Array of extra K8s objects to deploy",
          "items": {
            "required": []
          },
          "required": [],
          "title": "extraObjects"
        },
        "fullnameOverride": {
          "default": "",
          "description": "Overrides the fully qualified app name.",
          "required": [],
          "title": "fullnameOverride"
        },
        "global": {
          "description": "Global values are values that can be accessed from any chart or subchart by exactly the same name.",
          "required": [],
          "title": "global",
          "type": "object"
        },
        "image": {
          "properties": {
            "pullPolicy": {
              "default": "IfNotPresent",
              "description": "The image pull policy to use in grafana operator container",
              "required": [],
              "title": "pullPolicy"
            },
            "repository": {
              "default": "ghcr.io/grafana/grafana-operator",
              "description": "grafana operator image repository",
              "required": [],
              "title": "repository"
            },
            "tag": {
              "default": "",
              "description": "Overrides the image tag whose default is the chart appVersion.",
              "required": [],
              "title": "tag"
            }
          },
          "required": [],
          "title": "image",
          "type": "object"
        },
        "imagePullSecrets": {
          "description": "image pull secrets",
          "items": {
            "required": []
          },
          "required": [],
          "title": "imagePullSecrets"
        },
        "isOpenShift": {
          "default": "false",
          "description": "Determines if the target cluster is OpenShift. Additional rbac permissions for routes will be added on OpenShift",
          "required": [],
          "title": "isOpenShift"
        },
        "leaderElect": {
          "default": "false",
          "description": "If you want to run multiple replicas of the grafana-operator, this is not recommended.",
          "required": [],
          "title": "leaderElect"
        },
        "logging": {
          "properties": {
            "encoder": {
              "default": "console",
              "description": "Log encoding (\"console\", \"json\")",
              "required": [],
              "title": "encoder"
            },
            "level": {
              "default": "info",
              "description": "Configure the verbosity of logging (\"debug\", \"error\", \"info\")",
              "required": [],
              "title": "level"
            },
            "time": {
              "default": "rfc3339",
              "description": "Time encoding (\"epoch\", \"iso8601\", \"millis\", \"nano\", \"rfc3339\", \"rfc3339nano\")",
              "required": [],
              "title": "time"
            }
          },
          "required": [],
          "title": "logging",
          "type": "object"
        },
        "metricsService": {
          "properties": {
            "metricsPort": {
              "default": "9090",
              "description": "metrics service port",
              "required": [],
              "title": "metricsPort"
            },
            "pprofPort": {
              "default": "8888",
              "description": "port for the pprof profiling endpoint",
              "required": [],
              "title": "pprofPort"
            },
            "type": {
              "default": "ClusterIP",
              "description": "metrics service type",
              "required": [],
              "title": "type"
            }
          },
          "required": [],
          "title": "metricsService",
          "type": "object"
        },
        "nameOverride": {
          "default": "",
          "description": "Overrides the name of the chart.",
          "required": [],
          "title": "nameOverride"
        },
        "namespaceOverride": {
          "default": "",
          "description": "Overrides the namespace name.",
          "required": [],
          "title": "namespaceOverride"
        },
        "namespaceScope": {
          "default": "false",
          "description": "If the operator should run in namespace-scope or not, if true the operator will only be able to manage instances in the same namespace",
          "required": [],
          "title": "namespaceScope"
        },
        "nodeSelector": {
          "description": "pod node selector",
          "required": [],
          "title": "nodeSelector"
        },
        "podAnnotations": {
          "description": "pod annotations",
          "required": [],
          "title": "podAnnotations"
        },
        "podSecurityContext": {
          "description": "pod security context",
          "required": [],
          "title": "podSecurityContext"
        },
        "priorityClassName": {
          "default": "",
          "description": "pod priority class name",
          "required": [],
          "title": "priorityClassName"
        },
        "rbac": {
          "properties": {
            "create": {
              "default": "true",
              "description": "Specifies whether to create the ClusterRole and ClusterRoleBinding. If \"namespaceScope\" is true or \"watchNamespaces\" is set, this will create Role and RoleBinding instead.",
              "required": [],
              "title": "create"
            }
          },
          "required": [],
          "title": "rbac",
          "type": "object"
        },
        "resources": {
          "description": "grafana operator container resources",
          "required": [],
          "title": "resources"
        },
        "securityContext": {
          "properties": {
            "allowPrivilegeEscalation": {
              "default": "false",
              "description": "Whether to allow privilege escalation",
              "required": [],
              "title": "allowPrivilegeEscalation"
            },
            "capabilities": {
              "description": "A list of capabilities to drop",
              "properties": {
                "drop": {
                  "items": {
                    "anyOf": [
                      {
                        "required": [],
                        "type": "string"
                      }
                    ],
                    "required": []
                  },
                  "required": [],
                  "title": "drop",
                  "type": "array"
                }
              },
              "required": [],
              "title": "capabilities"
            },
            "readOnlyRootFilesystem": {
              "default": "true",
              "description": "Whether to allow writing to the root filesystem",
              "required": [],
              "title": "readOnlyRootFilesystem"
            },
            "runAsNonRoot": {
              "default": "true",
              "description": "Whether to require a container to run as a non-root user",
              "required": [],
              "title": "runAsNonRoot"
            }
          },
          "required": [],
          "title": "securityContext",
          "type": "object"
        },
        "serviceAccount": {
          "properties": {
            "annotations": {
              "description": "Annotations to add to the service account",
              "required": [],
              "title": "annotations"
            },
            "create": {
              "default": "true",
              "description": "Specifies whether a service account should be created",
              "required": [],
              "title": "create"
            },
            "name": {
              "default": "",
              "description": "The name of the service account to use. If not set and create is true, a name is generated using the fullname template",
              "required": [],
              "title": "name"
            }
          },
          "required": [],
          "title": "serviceAccount",
          "type": "object"
        },
        "serviceMonitor": {
          "properties": {
            "additionalLabels": {
              "description": "Set of labels to transfer from the Kubernetes Service onto the target",
              "required": [],
              "title": "additionalLabels"
            },
            "enabled": {
              "default": "false",
              "description": "Whether to create a ServiceMonitor",
              "required": [],
              "title": "enabled"
            },
            "interval": {
              "default": "1m",
              "description": "Set how frequently Prometheus should scrape",
              "required": [],
              "title": "interval"
            },
            "metricRelabelings": {
              "description": "MetricRelabelConfigs to apply to samples before ingestion",
              "items": {
                "required": []
              },
              "required": [],
              "title": "metricRelabelings"
            },
            "relabelings": {
              "description": "Set relabel_configs as per https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config",
              "items": {
                "required": []
              },
              "required": [],
              "title": "relabelings"
            },
            "scrapeTimeout": {
              "default": "10s",
              "description": "Set timeout for scrape",
              "required": [],
              "title": "scrapeTimeout"
            },
            "targetLabels": {
              "description": "Set of labels to transfer from the Kubernetes Service onto the target",
              "items": {
                "required": []
              },
              "required": [],
              "title": "targetLabels"
            },
            "telemetryPath": {
              "default": "/metrics",
              "description": "Set path to metrics path",
              "required": [],
              "title": "telemetryPath"
            }
          },
          "required": [],
          "title": "serviceMonitor",
          "type": "object"
        },
        "tolerations": {
          "description": "pod tolerations",
          "items": {
            "required": []
          },
          "required": [],
          "title": "tolerations"
        },
        "watchNamespaceSelector": {
          "default": "",
          "description": "Sets the `WATCH_NAMESPACE_SELECTOR` environment variable, it defines which namespaces the operator should be listening for based on a namespace label (e.g. `\"environment: dev\"`). By default, the operator watches all namespaces. To make it watch only its own namespace, check out `namespaceScope` option instead.",
          "required": [],
          "title": "watchNamespaceSelector"
        },
        "watchNamespaces": {
          "default": "",
          "description": "Sets the `WATCH_NAMESPACE` environment variable, it defines which namespaces the operator should be listening for (e.g. `\"grafana, foo\"`). By default, the operator watches all namespaces. To make it watch only its own namespace, check out `namespaceScope` option instead.",
          "required": [],
          "title": "watchNamespaces"
        }
      },
      "required": [],
      "title": "grafana-operator",
      "type": "object"
    },
    "hostname": {
      "default": "",
      "description": "The public hostname The hostname may be used in Prometheus alert to reference dashboard For a Grafana cloud instance, you need to enter: \u003cGrafana-cloud-stack-name\u003e.grafana.net",
      "format": "hostname",
      "required": [],
      "title": "Hostname"
    },
    "kubee_internal": {
      "description": "@ignored Internal Kubee constant",
      "properties": {
        "install_cross_dependency": {
          "const": false,
          "default": "false",
          "description": " const: false @schema Constant used to not output template from kubee cross dependency in Chart.yaml Don't change, don't touch",
          "required": [],
          "title": "install_cross_dependency"
        }
      },
      "required": [],
      "title": "kubee_internal"
    },
    "name": {
      "default": "grafana",
      "description": " It's used : * as selector to apply CRD objects such as Dashboard, .... to this instance. https://grafana.github.io/grafana-operator/docs/overview/#instanceselector * as the instance name",
      "required": [],
      "title": "name"
    },
    "namespace": {
      "default": "grafana",
      "description": "The installation namespace",
      "minLength": 1,
      "required": [],
      "title": "Namespace"
    },
    "prometheus": {
      "description": "Kubee Prometheus Chart",
      "properties": {
        "enabled": {
          "default": false,
          "description": "Enabled",
          "required": [],
          "title": "enabled",
          "type": "boolean"
        },
        "exporter_auth": {
          "description": " This is a global authentication configuration for all exporters",
          "properties": {
            "kube_rbac_proxy": {
              "description": " # https://github.com/brancz/kube-rbac-proxy Kube Prometheus uses rbac-proxy to add an authorization layer on exporter We disable it by default: - to minimize memory (20M by exporters) and the head-heck of authorization problem. - because there is also network policy If enabled, the exporter (node and state metrics) will get an extra containers that handle RBAC authorization",
              "properties": {
                "enabled": {
                  "default": false,
                  "required": [],
                  "title": "enabled",
                  "type": "boolean"
                },
                "version": {
                  "default": "v0.18.2",
                  "required": [],
                  "title": "version",
                  "type": "string"
                }
              },
              "required": [],
              "title": "kube_rbac_proxy"
            },
            "network_policy": {
              "description": " They allow only ingress communication from a prometheus server",
              "properties": {
                "enabled": {
                  "default": true,
                  "required": [],
                  "title": "enabled",
                  "type": "boolean"
                }
              },
              "required": [],
              "title": "network_policy"
            }
          },
          "required": [],
          "title": "exporter_auth"
        },
        "global": {
          "description": "Global values are values that can be accessed from any chart or subchart by exactly the same name.",
          "required": [],
          "title": "global",
          "type": "object"
        },
        "grafana_cloud": {
          "description": "grafana cloud remote write prometheus integration",
          "properties": {
            "enabled": {
              "default": false,
              "required": [],
              "title": "enabled",
              "type": "boolean"
            },
            "password": {
              "default": "",
              "description": "The password",
              "required": [],
              "title": "password",
              "type": "string"
            },
            "relabel_keep_regex": {
              "default": "",
              "description": " Example: `phpfpm_*` would send only the metrics starting with phpfpm `(phpfpm|argocd|node|traefik)_(.*)` would send the metrics starting with phpfpm, argocd, node and traefik Doc: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config By default, no filtering is applied",
              "required": [],
              "title": "relabel_keep_regex"
            },
            "username": {
              "default": "",
              "description": "The username",
              "required": [],
              "title": "username",
              "type": "string"
            }
          },
          "required": [],
          "title": "grafana_cloud",
          "type": "object"
        },
        "hostname": {
          "default": "",
          "description": " If not null, an ingress is added",
          "required": [],
          "title": "hostname"
        },
        "kubee_internal": {
          "description": " in the prometheus release It's used in the chart dependencies condition",
          "properties": {
            "install_cross_dependency": {
              "default": false,
              "description": "Don't modify the value, don't change",
              "required": [],
              "title": "install_cross_dependency",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "kubee_internal"
        },
        "max_block_duration": {
          "default": "30m",
          "description": "storage.tsdb.max-block-duration=2h) Note that the default value is * 1h for the prometheus query ui * 1h for the grafana explore panel (ie last hour) * 15m for Kubernetes dashboard * 24h for Headlamp We chose 30m to be below the target of 400Mi memory size with kubernetes monitoring installed",
          "required": [],
          "title": "max_block_duration"
        },
        "name": {
          "default": "kubee",
          "description": " (used by clients such as the grafana Chart to create a connection)",
          "required": [],
          "title": "name"
        },
        "namespace": {
          "default": "monitoring",
          "description": " used by clients such as the Grafana Chart to create the data source URI",
          "required": [],
          "title": "namespace"
        },
        "new_relic": {
          "description": "new relic remote write prometheus integration",
          "properties": {
            "bearer": {
              "default": "",
              "description": "for remote write",
              "required": [],
              "title": "bearer",
              "type": "string"
            },
            "enabled": {
              "default": false,
              "required": [],
              "title": "enabled",
              "type": "boolean"
            },
            "relabel_keep_regex": {
              "default": "",
              "description": " Example: `phpfpm_*` would send only the metrics starting with phpfpm `(phpfpm|argocd|node|traefik)_(.*)` would send the metrics starting with phpfpm, argocd, node and traefik Doc: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config By default, no filtering is applied",
              "required": [],
              "title": "relabel_keep_regex"
            }
          },
          "required": [],
          "title": "new_relic",
          "type": "object"
        },
        "operator": {
          "description": "Prometheus Operator",
          "properties": {
            "resources": {
              "description": "CPU/Memory",
              "properties": {
                "memory": {
                  "default": "50Mi",
                  "description": "Memory of the prometheus operator instance (value based on experience)",
                  "required": [],
                  "title": "memory",
                  "type": "string"
                }
              },
              "required": [],
              "title": "resources",
              "type": "object"
            }
          },
          "required": [],
          "title": "operator",
          "type": "object"
        },
        "resources": {
          "description": "Memory Limit",
          "properties": {
            "memory": {
              "default": "400Mi",
              "description": " Dynamically, if you query data above the max_block_duration, data is loaded in memory Why? 400Mi. This is: * the default of Kube-Prometheus with default memory setting. * the amount that we get after installing kubernetes-monitoring This is our goal",
              "required": [],
              "title": "memory"
            }
          },
          "required": [],
          "title": "resources",
          "type": "object"
        },
        "retention": {
          "default": "30m",
          "description": "storage.tsdb.retention.time=24h) Data in memory is 2 hour old, by setting retention to 2h, we don't allow to query data over 2 hours and to load data in memory The default is 24h Why 30m? Equal to max_block_duration so that we are sure that we will not increase memory of the prometheus pod",
          "required": [],
          "title": "retention"
        },
        "scrape_interval": {
          "default": "1m",
          "description": " It does influence memory as Prometheus keeps by default 2 hours of scraping in memory (max_block_duration) Default was 30s",
          "required": [],
          "title": "scrape_interval"
        },
        "secret": {
          "description": "The kind of secret created",
          "properties": {
            "kind": {
              "default": "Secret",
              "description": " Values supported `Secret` or `ExternalSecret` With `ExternalSecret`, you can use a gitops pull solutions such as ArgoCd/Flux.",
              "required": [],
              "title": "kind"
            }
          },
          "required": [],
          "title": "secret",
          "type": "object"
        },
        "version": {
          "default": "3.1.0",
          "description": " https://github.com/prometheus/prometheus/releases",
          "required": [],
          "title": "version"
        }
      },
      "required": [],
      "title": "kubee-prometheus",
      "type": "object"
    },
    "type": {
      "default": "internal",
      "description": "The type of instance: * internal: installation of grafana in the cluster. * external: grafana api (for instance: grafana cloud instance, if external, the `api_token` is mandatory). An empty type does not install any instance",
      "enum": [
        "internal",
        "external",
        ""
      ],
      "required": [],
      "title": "type"
    }
  },
  "required": [
    "enabled",
    "namespace"
  ],
  "type": "object"
}